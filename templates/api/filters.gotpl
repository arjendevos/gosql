// Generated by gosql: DO NOT EDIT.
package {{ .PackageName }}

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"

	{{ range .Imports }}
		"{{ . }}"
	{{ end }}
)
type FilterValue struct {
	Equals    *string `json:"equals"`
	NotEquals *string `json:"notEquals"`
	// IsNull *bool `json:"isNull"`
	// IsNotNull *bool `json:"isNotNull"`
	IsIn                 *[]string `json:"isIn"`
	IsNotIn              *[]string `json:"isNotIn"`
	IsLessThan           *string   `json:"isLessThan"`
	IsLessThanOrEqual    *string   `json:"isLessThanOrEqual"`
	IsGreaterThan        *string   `json:"isGreaterThan"`
	IsGreaterThanOrEqual *string   `json:"isGreaterThanOrEqual"`
	Or 				 *FilterValue `json:"or"`
}

func parseFilterValue(filterValue *FilterValue, column string, queryMods []qm.QueryMod) []qm.QueryMod {
	if queryMods == nil {
		queryMods = []qm.QueryMod{}
	}

	if filterValue.Equals != nil {
		queryMods = append(queryMods, qm.Where(column +" = ?", * filterValue.Equals))
	}

	if filterValue.NotEquals != nil {
		queryMods = append(queryMods, qm.Where(column +" != ?", * filterValue.NotEquals))
	}

	if filterValue.IsIn != nil {
		queryMods = append(queryMods, qm.WhereIn(column +" IN ?", * filterValue.IsIn))
	}

	if filterValue.IsNotIn != nil {
		queryMods = append(queryMods, qm.WhereIn(column +" NOT IN ?", * filterValue.IsNotIn))
	}

	if filterValue.IsLessThan != nil {
		queryMods = append(queryMods, qm.Where(column +" < ?", * filterValue.IsLessThan))
	}

	if filterValue.IsLessThanOrEqual != nil {
		queryMods = append(queryMods, qm.Where(column +" <= ?", * filterValue.IsLessThanOrEqual))
	}

	if filterValue.IsGreaterThan != nil {
		queryMods = append(queryMods, qm.Where(column +" > ?", * filterValue.IsGreaterThan))
	}

	if filterValue.IsGreaterThanOrEqual != nil {
		queryMods = append(queryMods, qm.Where(column +" >= ?", * filterValue.IsGreaterThanOrEqual))
	}

	// if filterValue.Or != nil {
	// 	return qm.Expr(
	// 		qm.Expr(queryMods...),
	// 		qm.Or2(parseFilterValue(filterValue.Or, column, nil)),
	// 	)
	// }

	return queryMods
}

{{ range $controller := .Controllers }}
	{{ range $column := .Columns }}
		{{ if .Type.IsNullable }}
			type {{ $controller.CamelName }}{{ $column.CamelName }}Filter struct {
				*FilterValue
				IsNull *bool `json:"isNull"`
				IsNotNull *bool `json:"isNotNull"`
			}

			func parse{{$controller.CamelName}}{{.CamelName}}(filterValue *{{ $controller.CamelName }}{{ $column.CamelName }}Filter)[]qm.QueryMod {
				var queryMods []qm.QueryMod

				if filterValue != nil {
					if filterValue.IsNull != nil {
						queryMods = append(queryMods, qm.Where("{{ .SnakeName }} IS NULL"))
					}

					if filterValue.IsNotNull != nil {
						queryMods = append(queryMods, qm.Where("{{ .SnakeName }} IS NOT NULL"))
					}

					if filterValue.FilterValue != nil {
						return parseFilterValue(filterValue.FilterValue, "{{ .SnakeName }}", queryMods)
					}
				}

				return queryMods
			}
		{{- end}}
	{{- end }}

	type {{ .CamelName }}Filter struct {
		{{ range $column := .Columns }}
			{{- if .Type.IsNullable }}
				{{ .CamelName }} *{{ $controller.CamelName }}{{ .CamelName }}Filter `json:"{{ .SnakeName }}"`
			{{- else}}
				{{- if .IsRelation}}
					{{ .CamelName }} *{{ .DatabaseName.CamelName }}Filter `json:"{{ .SnakeName }}"`
				{{- else}}
					{{ .CamelName }} *FilterValue `json:"{{ .SnakeName }}"`	
				{{- end}}
			{{- end }}
		{{- end }}
	}

	func parse{{ .CamelName }}Filter(filter string) (*{{ .CamelName }}Filter, error) {
		var filterValue {{ .CamelName }}Filter
		if err := json.Unmarshal([]byte(filter), &filterValue); err != nil {
			return nil, err
		}

		return &filterValue, nil
	}

	func parse{{ .CamelName}}FilterToMods(filter *{{ .CamelName}}Filter, prefix string) ([]qm.QueryMod, error) {
		var queryMods []qm.QueryMod
		
		{{ range $column := .Columns }}
			if filter.{{ .CamelName }} != nil {
				{{- if .Type.IsNullable }}
					columnMods := parse{{$controller.CamelName}}{{.CamelName}}(filter.{{ .CamelName }})
					if len(columnMods) > 0 {
						queryMods = append(queryMods, qm.Expr(columnMods...))
					}
				{{- else}}
					{{- if .IsRelation}}
						{{toLower .CamelName}}QueryMods, err := parse{{ .DatabaseName.CamelName }}FilterToMods(filter.{{ .CamelName }}, "{{.SnakeName}}.")
						if err != nil {
							return nil, err
						}

						var joinQueryMods []qm.QueryMod
						joinQueryMods = append(joinQueryMods, qm.From("can_be_anything"))
						joinQueryMods = append(joinQueryMods, qm.Where("can_be_anything.id = can_be_anything2.can_be_anything_id"))
						joinQueryMods = append(joinQueryMods, {{toLower .CamelName}}QueryMods...)
				
						q := dm.NewQuery(joinQueryMods...)
						s, args:=queries.BuildQuery(q)
				
						joinQueryString := "AND"+strings.Split(s, "AND")[1]
						joinQueryString = strings.TrimSuffix(joinQueryString, ";")
				
						for i, arg := range args {
							// TODO find another way to do this
							joinQueryString = strings.Replace(joinQueryString, fmt.Sprintf("$%v",i+1 ), fmt.Sprintf("'%v'", arg), 1)
						}
				
						queryMods = append(queryMods, qm.InnerJoin(fmt.Sprintf("{{.SnakeName}} ON {{.SnakeName}}.id = {{ $controller.SnakeName }}.{{ .SnakeName }}_id %v", joinQueryString)))

						// queryMods = append(queryMods, qm.From("{{ .SnakeName }}"))
						// {{toLower .CamelName}}QueryMods = append({{toLower .CamelName}}QueryMods, qm.Where("{{ .SnakeName }}.id = {{ $controller.SnakeName }}.{{ .SnakeName }}_id"))
						// queryMods = append(queryMods, qm.Expr({{toLower .CamelName}}QueryMods...))
					{{- else}}
						columnMods := parseFilterValue(filter.{{ .CamelName }}, prefix +"{{ .SnakeName }}", nil)
						if len(columnMods) > 0 {
							queryMods = append(queryMods, qm.Expr(columnMods...))
						}
					{{- end}}
				{{- end }}
			}
		{{- end }}

		return queryMods, nil
	}
{{ end }}
