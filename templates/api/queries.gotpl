// Generated by gosql: DO NOT EDIT.
package {{ .PackageName }}

import (
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"strings"
	"errors"
	"encoding/base64"
	"time"
	"fmt"

)

{{ $authFields := .AuthFields }}
{{ $hasMultipleAuthFields := .HasMultipleAuthFields }}

type Cursor struct {
	IsPrevious bool   `json:"is_previous"`
	IsNext     bool   `json:"is_next"`
	ID     string `json:"cursor"`
	CreatedAt string `json:"created_at"`
}

const DIRECTION_SPLITTER = "_____"
const CURSOR_SPLITTER = "_*_*_*_*_*_"

func parseCursor(rawCursor string) (*Cursor, error) {
	rawCursor, err := base64DecodeCursor(rawCursor)
	if err != nil {
		return nil, err
	}

	if strings.HasPrefix(rawCursor, "prev"+DIRECTION_SPLITTER) {
		cursor := strings.TrimPrefix(rawCursor, "prev"+DIRECTION_SPLITTER)
		s := strings.Split(cursor, CURSOR_SPLITTER)
		return &Cursor{
			IsPrevious: true,
			IsNext:     false,
			ID:    s[0],
			CreatedAt: s[1],
		}, nil
	}

	if strings.HasPrefix(rawCursor, "next"+DIRECTION_SPLITTER) {
		cursor := strings.TrimPrefix(rawCursor, "next"+DIRECTION_SPLITTER)
		s := strings.Split(cursor, CURSOR_SPLITTER)
		return &Cursor{
			IsPrevious: false,
			IsNext:     true,
			ID:    s[0],
			CreatedAt: s[1],
		}, nil
	}

	return nil, errors.New("invalid cursor")
}

func GenerateNextPageCursor(id *string, created_at *time.Time) *string {
	if id == nil || created_at == nil{
		return nil
	}

	c := base64EncodeCursor("next" + DIRECTION_SPLITTER + *id +CURSOR_SPLITTER + created_at.UTC().Format("2006-01-02 15:04:05.999999-07"))
	return &c
}

func GeneratePrevPageCursor(id *string, created_at *time.Time) *string {
	if id == nil || created_at == nil {
		return nil
	}

	c := base64EncodeCursor("prev" + DIRECTION_SPLITTER + *id+CURSOR_SPLITTER + created_at.UTC().Format("2006-01-02 15:04:05.999999-07"))
	return &c
}

func base64DecodeCursor(rawCursor string) (string, error) {
	b, err:= base64.StdEncoding.DecodeString(rawCursor)
	if err != nil {
			return "", err
	}
	return string(b), nil
}


func base64EncodeCursor(cleanCursor string) string {
	return base64.StdEncoding.EncodeToString([]byte(cleanCursor))
}

{{ range $controller := .Controllers }}
	{{ $columns := .Columns }}

	type {{ .CamelName }}Query struct {
		Relations *{{ .CamelName }}Relations `json:"relations"`
		SelectColumns []string `json:"select_columns"`
	}

	func parse{{ .CamelName }}Query(context *gin.Context) (*{{ .CamelName }}Query, error) {
		relations := context.DefaultQuery("rels", "{}")
		selects := context.DefaultQuery("select", "[]")
		
		r, err := parse{{ .CamelName }}Relations(relations)
		if err != nil {
			return nil, err
		}

		s, err := parse{{ .CamelName }}Selects(selects)
		if err != nil {
			return nil, err
		}

		return &{{ .CamelName }}Query{
			Relations: r,
			SelectColumns: s,
		}, nil
	}

	func parse{{ .CamelName }}QueryToMods(context *gin.Context, parentLimit int) ([]qm.QueryMod, error) {
		query, err := parse{{ .CamelName }}Query(context)
		if err != nil {
			return nil, err
		}

		var queryMods []qm.QueryMod

		if query.Relations != nil {
			relationQueryMods, err := parse{{ .CamelName }}RelationsToMods(query.Relations, "", parentLimit)
			if err != nil {
				return nil, err
			}
			queryMods = append(queryMods, relationQueryMods...)
		}

		if len(query.SelectColumns) > 0 {
			selectQueryMods, err := parse{{ .CamelName }}SelectsToMods(query.SelectColumns)
			if err != nil {
				return nil, err
			}
			queryMods = append(queryMods, selectQueryMods)
		}

		return queryMods, nil
	}

	

	type {{ .CamelName }}ListQuery struct {
		Limit  int    `json:"limit"`
		Cursor *Cursor `json:"cursor"`
		Filter *{{ .CamelName }}Filter `json:"filter"`
		Orders *{{ .CamelName }}OrderColumns `json:"orders"`
	}
	
	func parse{{ .CamelName }}ListQuery(context *gin.Context) (*{{ .CamelName }}ListQuery, error) {
		limit := context.DefaultQuery("limit", "10")
		filter := context.DefaultQuery("filter", "{}")
		orders := context.DefaultQuery("order", "{}")
		rawCursor, hasCursor := context.GetQuery("cursor")


		f, err := parse{{ .CamelName }}Filter(filter)
		if err != nil {
			return nil, err
		}

		o, err := parse{{ .CamelName }}Orders(orders)
		if err != nil {
			return nil, err
		}

		limitInInt, err := strconv.Atoi(limit)
		if err != nil {
			return nil, err
		}

		if limitInInt > 50 || limitInInt <= 0 {
			limitInInt = 50
		}

		var cursor *Cursor
		if hasCursor {
			var err error
			cursor, err = parseCursor(rawCursor)
			if err != nil{
				return nil, err
			}
		}

		return &{{ .CamelName }}ListQuery{
			Limit:  limitInInt,
			Filter: f,
			Orders: o,
			Cursor: cursor,
		}, nil
	}

	func Parse{{ .CamelName }}ListQueryToMods(context *gin.Context) ([]qm.QueryMod, *{{.CamelName}}ListQuery, error) {
		query, err := parse{{ .CamelName }}ListQuery(context)
		if err != nil {
			return nil, nil, err
		}

		var queryMods []qm.QueryMod

		hasAlreadyOrdering := false
		if query.Cursor != nil {
			if query.Cursor.IsPrevious {
				hasAlreadyOrdering = true
				expr := qm.Expr(
					qm.Where("{{.SnakeName}}.created_at >= ?", query.Cursor.CreatedAt), 
					qm.Expr(
						qm.Where("{{.SnakeName}}.created_at > ?", query.Cursor.CreatedAt), 
						qm.Or2(qm.Where("{{.SnakeName}}.id > ?", query.Cursor.ID)),
					), 
					qm.OrderBy("{{.SnakeName}}.created_at DESC, {{.SnakeName}}.id ASC"),
				)

				if query.Orders != nil && query.Orders.CreatedAt != nil && *query.Orders.CreatedAt == "asc" {
					expr = qm.Expr(
						qm.Where("{{.SnakeName}}.created_at >= ?", query.Cursor.CreatedAt),
						qm.Expr(
							qm.Where("{{.SnakeName}}.created_at > ?", query.Cursor.CreatedAt),
							qm.Or2(qm.Where("{{.SnakeName}}.id > ?", query.Cursor.ID)),
						),
						qm.OrderBy("{{.SnakeName}}.created_at ASC, {{.SnakeName}}.id ASC"),
					)
				}

				queryMods = append(queryMods, expr)
			}

			if query.Cursor.IsNext {
				hasAlreadyOrdering = true
				expr := qm.Expr(
					qm.Where("{{.SnakeName}}.created_at <= ?", query.Cursor.CreatedAt), 
					qm.Expr(
						qm.Where("{{.SnakeName}}.created_at < ?", query.Cursor.CreatedAt), 
						qm.Or2(qm.Where("{{.SnakeName}}.id < ?", query.Cursor.ID)),
					), 
					qm.OrderBy("{{.SnakeName}}.created_at DESC, {{.SnakeName}}.id ASC"),
					// qm.OrderBy("{{.SnakeName}}.created_at, {{.SnakeName}}.id ASC"),
				)

				if query.Orders != nil && query.Orders.CreatedAt != nil && *query.Orders.CreatedAt == "asc"{
						expr = qm.Expr(
							qm.Where("{{.SnakeName}}.created_at <= ?", query.Cursor.CreatedAt),
							qm.Expr(
								qm.Where("{{.SnakeName}}.created_at < ?", query.Cursor.CreatedAt),
								qm.Or2(qm.Where("{{.SnakeName}}.id < ?", query.Cursor.ID)),
							),
							qm.OrderBy("{{.SnakeName}}.created_at ASC, {{.SnakeName}}.id ASC"),
						)
				}

				queryMods = append(queryMods, expr)
			}
		} 

		if !hasAlreadyOrdering{
			if query.Orders != nil && query.Orders.CreatedAt != nil  {
				queryMods = append(queryMods, qm.OrderBy(fmt.Sprintf("{{.SnakeName}}.created_at %s", strings.ToUpper(*query.Orders.CreatedAt))))
			} else {
				queryMods = append(queryMods, qm.OrderBy("{{.SnakeName}}.created_at DESC"))
			}
		}

		// queryMods = append(queryMods, qm.Offset(query.Page))
		queryMods = append(queryMods, qm.Limit(query.Limit+1))
		
		if query.Filter != nil {
			filterQueryMods, err := parse{{ .CamelName }}FilterToMods(query.Filter, "")
			if err != nil {
				return nil, nil, err
			}
			queryMods = append(queryMods, filterQueryMods...)
		}

		if query.Orders != nil {
			ordersQueryMods, err := parse{{ .CamelName }}OrdersToMods(query.Orders)
			if err != nil {
				return nil, nil, err
			}
			queryMods = append(queryMods, ordersQueryMods...)
		}

		extraMods,err := parse{{ .CamelName }}QueryToMods(context, query.Limit)
		if err != nil {
			return nil, nil, err
		}

		return append(queryMods, extraMods...), query, nil
	}

	func Parse{{ .CamelName }}ByIDParamToMods(context *gin.Context) ([]qm.QueryMod, error) {
		id := context.Param("id")
		// idInInt, err := strconv.Atoi(id)
		// if err != nil {
		// 	return nil, err
		// }

		queryMods, err := parse{{ .CamelName }}QueryToMods(context, 1)
		if err != nil {
			return nil, err
		}

		return append(queryMods, []qm.QueryMod{qm.Where("{{.SnakeName}}.id = ?", id)}...), nil
	}

	{{ if $hasMultipleAuthFields }} 
		type {{ .CamelName }}AuthQuery struct {
			{{ range $auth := $authFields }}
				{{- if isAuthFieldInModel $columns .}}
					{{ .TableCamelName }} bool `json:"{{ .TableSnakeName }}"`
				{{- end }}
			{{- end }}
		}

		func parse{{.CamelName}}AuthQuery(context *gin.Context) (*{{.CamelName}}AuthQuery, error) {
			from := context.DefaultQuery("from", "all")

			{{ range $auth := $authFields }}
				{{- if isAuthFieldInModel $columns .}}
					from{{ .TableCamelName }} := false
				{{- end }}
			{{- end}}

			switch from {
				{{- range $auth := $authFields }}
					{{- if isAuthFieldInModel $columns .}}
						case "{{ .TableSnakeName }}":
							from{{ .TableCamelName }} = true
					{{- end }}
				{{- end }}
				default:
					{{- range $auth := $authFields }}
						{{- if isAuthFieldInModel $columns .}}
							from{{ .TableCamelName }} = true
						{{- end}}
					{{- end }}
			}

			return &{{.CamelName}}AuthQuery{
				{{- range $auth := $authFields }}
					{{- if isAuthFieldInModel $columns .}}
						{{ .TableCamelName }}: from{{ .TableCamelName }},
					{{- end}}
				{{- end }}
			}, nil
		}
	{{- end }}

	func Parse{{ .CamelName }}AuthToMods(context *gin.Context) ([]qm.QueryMod, error) {
		{{- if and (areAuthFieldsInModel .Columns $authFields) ($hasMultipleAuthFields) (not .IsAuthUser) (not .IsAuthOrganization)}}
			authQuery, err := parse{{ .CamelName }}AuthQuery(context)
			if err != nil {
				return nil, err
			}
		{{- end}}

		var queryMods []qm.QueryMod
		{{ $isAuthUser := .IsAuthUser}}
		{{ $isAuthOrganization := .IsAuthOrganization}}

		{{ range $auth := $authFields }}
			{{- if isAuthFieldInModel $columns .}}
				{{- if and ($hasMultipleAuthFields) (not $isAuthUser) (not $isAuthOrganization)}}
					if authQuery.{{ .TableCamelName }} {
						queryMods = append(queryMods, qm.Where("{{ $controller.SnakeName }}.{{ .SnakeName }} = ?", context.Value("{{ .SnakeName }}").({{ .GoType }})))
					}
				{{- else }}
					queryMods = append(queryMods, qm.Where("{{ $controller.SnakeName }}.{{ .SnakeName }} = ?", context.Value("{{ .SnakeName }}").({{ .GoType }})))
				{{- end}}
			{{- else }}
				{{- if or (and $isAuthUser .IsFromUserTable) (and $isAuthOrganization .IsFromOrganizationTable)}}
					queryMods = append(queryMods, qm.Where("{{ $controller.SnakeName }}.{{ toLower .NormalName }} = ?", context.Value("{{ .SnakeName }}").({{ .GoType }})))
				{{- end}}
				
			{{- end}}
		{{- end}}


		return queryMods, nil
	}

{{ end }}